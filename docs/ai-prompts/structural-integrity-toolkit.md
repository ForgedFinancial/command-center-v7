# The Structural Integrity Toolkit
## Prompts That Make Your Assistant Bulletproof Your Code

---

## WHAT THIS IS

These prompts turn your Claude assistant into a **structural engineer** 
for your codebase. Before you add floors to a building, you check 
if the foundation can hold them. Same idea here.

Every prompt is designed to be pasted directly into a conversation 
with your assistant. They work on any codebase ‚Äî HTML, JS, React, 
Python, anything ‚Äî but they're especially built for the kind of 
large single-file applications you're working with.

---

## SECTION 1: CODE LOGIC VERIFICATION
*"Does every line make sense and do what it claims to do?"*

### PROMPT 1A: "The Line-by-Line Logic Audit"

```
 
```

### PROMPT 1B: "The Data Flow Tracer"

```
Trace the complete lifecycle of data through this application. 
I need to know every place data is created, read, modified, saved, 
and displayed ‚Äî and verify there are no broken links in the chain.

[Paste your code or describe the data model]

For each data entity (tasks, contacts, notes, settings, etc.):

ENTITY: [name]
BORN: Where/how is this data created?
  - Function that creates it: [name, line]
  - Required fields at creation: [list]
  - Optional fields: [list]
  - Default values: [list]
  - Validation at creation: [exists? what checks?]

STORED: Where does this data live?
  - In memory: [variable name, structure]
  - Persisted: [localStorage key? API? file?]
  - Format when stored: [JSON structure]

READ: Every place this data is accessed?
  - [Function name] reads [which fields] for [purpose]
  - [Function name] reads [which fields] for [purpose]
  - ... (list ALL)

MODIFIED: Every place this data is changed?
  - [Function name] changes [which fields] when [trigger]
  - [Function name] changes [which fields] when [trigger]
  - ... (list ALL)

DISPLAYED: Every place this data appears in the UI?
  - [Component/element] shows [which fields]
  - [Component/element] shows [which fields]

DELETED: How is this data removed?
  - Function that deletes: [name]
  - Cascade effects: [what else gets deleted/orphaned?]
  - Confirmation required: [yes/no]
  - Recovery possible: [yes/no]

BROKEN CHAINS FOUND:
  - [Data is created but never displayed]
  - [Data is displayed but could be undefined]
  - [Data is modified but the display isn't refreshed]
  - [Data is deleted but references to it remain]
  - [Data is saved in one format but read expecting another]
```

### PROMPT 1C: "The Conditional Logic Validator"

```
Extract every if/else, switch, ternary, and conditional expression 
in this code. For each one, verify it handles ALL possible cases.

[Paste your code section]

For each conditional, document:

LOCATION: [function name + approximate position]
CONDITION: [the actual test]
HANDLES TRUE: [what happens] ‚úÖ
HANDLES FALSE: [what happens] ‚úÖ or ‚ùå MISSING
HANDLES NULL/UNDEFINED: ‚úÖ or ‚ùå MISSING
HANDLES EDGE CASES:
  - Empty string? [‚úÖ/‚ùå]
  - Zero? [‚úÖ/‚ùå]
  - Negative number? [‚úÖ/‚ùå]
  - Empty array? [‚úÖ/‚ùå]
  - Wrong type? [‚úÖ/‚ùå]

FLAGS:
üî¥ UNHANDLED CASE: [condition] can be [value] and nothing catches it
üü° IMPLICIT FALLTHROUGH: [condition] relies on truthiness but [value] is falsy
üü¢ SOLID: All cases handled

PAY SPECIAL ATTENTION TO:
- switch statements missing default cases
- if/else chains that don't cover all enum values
- .find() results used without null checking
- Array[index] accessed without bounds checking
- Object.property accessed without existence checking
- .split() / .trim() / .toLowerCase() called on potentially null values
- parseInt / parseFloat on potentially non-numeric strings
- Date parsing on potentially invalid date strings
```

---

## SECTION 2: STRUCTURAL EFFICIENCY AUDIT
*"Is this the smartest way to build this, or are we wasting effort?"*

### PROMPT 2A: "The Architecture Efficiency Review"

```
Review this codebase for structural efficiency. I don't want the 
fanciest code ‚Äî I want the SIMPLEST code that does the job reliably. 
Find every place where we're overcomplicating things.

[Paste your code]

CHECK FOR:

REDUNDANT CODE:
- Functions that do nearly the same thing (should be one function 
  with parameters)
- CSS rules that repeat the same properties (should use shared classes)
- HTML structures that are copy-pasted with minor changes (should be 
  generated by a function)
- List every instance with the locations of both copies.

OVER-ENGINEERING:
- Abstractions that only have one use (unnecessary wrapper)
- Configuration objects for things that never change
- Event systems for things that could be direct function calls
- State management patterns more complex than the data requires
- Generic solutions where a specific solution would be simpler and clearer

UNDER-ENGINEERING:
- Inline styles that should be CSS classes
- Magic numbers that should be named constants
- Hardcoded strings that should be configurable
- Logic duplicated across functions that should be extracted
- DOM queries repeated instead of cached in variables

EXPENSIVE OPERATIONS:
- DOM queries inside loops (should query once, iterate the result)
- Full re-renders when partial updates would work
- Recalculating values that haven't changed
- Creating objects/arrays in render functions (recreated every render)
- String building with concatenation in loops (should use arrays + join)

DEPENDENCY CHAINS:
- Function A calls B calls C calls D ‚Äî is this chain necessary?
- Are there circular dependencies (A needs B, B needs A)?
- Could any chain be shortened?

OUTPUT FORMAT:
For each finding:
[WHAT]: Description of the issue
[WHERE]: Location in code
[CURRENT COST]: Why this matters (performance, maintenance, bug risk)
[BETTER APPROACH]: The simpler/more efficient way
[EFFORT TO FIX]: Quick / Medium / Major
[RISK OF FIXING]: Low / Medium / High (could it break something?)
```

### PROMPT 2B: "The Single-File Stress Test"

```
My application is a single HTML file with embedded CSS and JavaScript.
Evaluate whether this structure is sustainable and find the pressure 
points that will cause problems as it grows.

[Paste code or state the line count and describe sections]

EVALUATE:

FILE SIZE HEALTH:
- Current line count and file size
- At what size will this become unmanageable? (for humans AND for AI)
- What percentage of the file changes when I modify one feature?
- What percentage of the file is shared infrastructure vs. feature code?

NAMESPACE POLLUTION:
- How many global variables exist?
- How many global functions exist?
- Are any names generic enough to conflict? (e.g., 'data', 'render', 'update')
- List every global that could be safely encapsulated

COUPLING ANALYSIS:
- Which features depend on each other?
- Which features are independent?
- If I deleted the CRM code, would anything else break?
- If I deleted the TaskBoard code, would anything else break?
- Draw a dependency map: Feature A ‚Üí depends on ‚Üí [list]

CSS SCOPE RISK:
- Are there any CSS class names generic enough to leak across sections?
  (e.g., '.card', '.title', '.active' without a prefix)
- Are there any CSS rules that use element selectors (div, span, p) 
  that could match too broadly?
- List specific collision risks

RECOMMENDED SEPARATION PLAN:
If/when we split this into multiple files, what's the cleanest way?
- What becomes the "core" that everything needs?
- What can be extracted with ZERO changes to other code?
- What would need refactoring to separate?
- Priority order for extraction (lowest risk first)
```

### PROMPT 2C: "The State Architecture Review"

```
Audit the state management in this application. State is the #1 
source of bugs in any app ‚Äî I need to know if mine is solid.

[Paste the code where state is defined and managed]

ANALYZE:

STATE INVENTORY:
List every piece of state in the app:
- [Variable/key] | [Type] | [Where stored] | [Who reads it] | [Who writes it]

SINGLE SOURCE OF TRUTH:
- Is each piece of data stored in exactly ONE place?
- Are there any places where the same data is duplicated?
  (e.g., stored in state AND in a DOM element's attribute)
- If duplicated: what happens when they get out of sync?

STATE TRANSITIONS:
- For each state variable, what are ALL the valid values?
- Are there any invalid states the app can get into?
  (e.g., a task marked "completed" but still in the "in_progress" column)
- What prevents invalid state transitions?

PERSISTENCE INTEGRITY:
- What triggers a save to localStorage/storage?
- Is save called after EVERY state change, or could changes be lost?
- What happens if save fails (localStorage full, permission denied)?
- What happens if the saved data is corrupted on load?
- Is there schema validation when loading saved data?
- What happens when the code adds new fields that old saved data doesn't have?

RENDER SYNCHRONIZATION:
- After state changes, does the UI ALWAYS update?
- Are there code paths where state changes but render is NOT called?
- List every function that modifies state ‚Üí does it also trigger a render?

RACE CONDITIONS:
- Can two things modify the same state at the same time?
  (e.g., a timer callback and a user click)
- Are there any async operations that could complete out of order?
- What happens if the user acts faster than the app updates?

VERDICT:
State architecture is: SOLID / HAS GAPS / FRAGILE
Top 3 risks and how to fix them.
```

---

## SECTION 3: FOUNDATION REINFORCEMENT
*"Make the base so solid that nothing we build on top can crack it"*

### PROMPT 3A: "The Foundation Health Check"

```
Before I add any new features, I need to verify the foundation of 
this app is rock solid. Check every core system that other features 
depend on.

[Paste your code]

CHECK THESE FOUNDATION SYSTEMS:

1. INITIALIZATION SEQUENCE:
   - What happens when the page loads, in exact order?
   - Are there any dependencies on load order that could fail?
   - What if a script loads before the DOM is ready?
   - What if an external resource (font, CDN) fails to load?
   - Is there error handling around initialization?
   ‚Üí Status: SOLID / NEEDS WORK

2. NAVIGATION SYSTEM:
   - Does every nav item correctly show its page?
   - Does the URL/state update when navigating?
   - Does the back button work (if applicable)?
   - What happens if you navigate to a non-existent page?
   - Does navigation clean up the previous page (event listeners, timers)?
   ‚Üí Status: SOLID / NEEDS WORK

3. DATA PERSISTENCE (Save/Load):
   - Is save called at every point it should be?
   - Does load handle missing keys gracefully?
   - Does load handle corrupted data gracefully?
   - Does load handle schema changes (new fields added in code)?
   - What's the maximum data size before storage fails?
   - Is there any data that exists in memory but never gets saved?
   ‚Üí Status: SOLID / NEEDS WORK

4. RENDER PIPELINE:
   - Is there a clear pattern for how pages render?
   - Do all pages follow the same render pattern?
   - Are renders idempotent (calling render twice gives same result)?
   - Do renders clean up old content before writing new content?
   - Do renders re-attach event listeners properly?
   ‚Üí Status: SOLID / NEEDS WORK

5. EVENT HANDLING:
   - Are events attached via delegation or direct binding?
   - Are there any events that get attached multiple times?
     (e.g., re-running a render adds duplicate listeners)
   - Are there events that should be removed but aren't?
   - Do events reference DOM elements that might not exist yet?
   ‚Üí Status: SOLID / NEEDS WORK

6. ERROR BOUNDARIES:
   - If one feature's code throws an error, does the whole app crash?
   - Are there try/catch blocks around risky operations?
   - Is there a global error handler?
   - Are errors logged anywhere the developer can see them?
   - Do errors show user-friendly messages or raw stack traces?
   ‚Üí Status: SOLID / NEEDS WORK

7. UTILITY FUNCTIONS:
   - ID generation: Is it truly unique? Could two items get the same ID?
   - Date formatting: Consistent across the app? Timezone-aware?
   - String sanitization: Protected against XSS?
   - DOM helpers: Reliable element selection?
   ‚Üí Status: SOLID / NEEDS WORK

OVERALL FOUNDATION SCORE: [X/7 systems solid]
MUST-FIX BEFORE BUILDING MORE: [list]
```

### PROMPT 3B: "The Defensive Coding Hardener"

```
I need you to add defensive coding to this section of my app. 
Every function should be hardened against unexpected input, 
missing data, and runtime errors ‚Äî without changing what the 
function does when given good input.

[Paste a section of your code]

For each function, add:

1. INPUT GUARDS ‚Äî at the top of every function:
   - Check that required parameters exist
   - Check that parameters are the expected type
   - Return early with a safe default if guards fail
   - NEVER throw errors that crash the app ‚Äî handle gracefully

   Example:
   BEFORE: function renderCard(task) {
             return `<div>${task.title}</div>`;
           }

   AFTER:  function renderCard(task) {
             if (!task || typeof task !== 'object') return '';
             const title = task.title || 'Untitled';
             return `<div>${title}</div>`;
           }

2. NULL-SAFE PROPERTY ACCESS ‚Äî for every dot notation chain:
   BEFORE: const name = contact.fields.firstName;
   AFTER:  const name = contact?.fields?.firstName || '';

3. ARRAY SAFETY ‚Äî for every array operation:
   BEFORE: const first = items[0].name;
   AFTER:  const first = items?.[0]?.name || 'None';

   BEFORE: items.forEach(...)
   AFTER:  (items || []).forEach(...)

4. DOM SAFETY ‚Äî for every DOM query:
   BEFORE: document.getElementById('myEl').innerHTML = html;
   AFTER:  const el = document.getElementById('myEl');
           if (el) el.innerHTML = html;

5. TRY/CATCH WRAPPING ‚Äî around these operations:
   - JSON.parse (can throw on invalid JSON)
   - localStorage access (can throw when full or blocked)
   - fetch calls (can throw on network failure)
   - Any operation on external/user data

6. SAFE DEFAULTS ‚Äî for every variable that could be undefined:
   BEFORE: const count = data.items.length;
   AFTER:  const count = (data?.items || []).length;

RULES:
- Do NOT change the function's behavior when given correct input
- Do NOT add console.log or alerts ‚Äî fail silently or use a logging function
- DO preserve the original code structure ‚Äî just add guards
- Show me the BEFORE and AFTER for each change so I can verify

SAFETY SCORE BEFORE: [X/10]
SAFETY SCORE AFTER: [X/10]
```

### PROMPT 3C: "The Error Recovery System"

```
Design and implement an error recovery system for this application. 
When things go wrong, the app should recover gracefully ‚Äî not crash, 
not show blank screens, not lose data.

[Paste your code or describe the app structure]

BUILD THESE THREE LAYERS:

LAYER 1: PREVENTION (stop errors before they happen)
- Input validation functions for every data type in the app
- Schema validation for loaded/saved data
- Type coercion utilities (safe number parsing, safe date parsing, etc.)
- Give me the actual utility functions to add to the codebase

LAYER 2: CONTAINMENT (when errors happen, contain the blast radius)
- Global error handler: window.onerror and unhandledrejection
- Feature-level try/catch wrappers for each page's render function
- Safe render pattern: if a page render fails, show an error 
  state for THAT PAGE, not a white screen
- Give me the actual wrapper code

LAYER 3: RECOVERY (get back to a working state)
- Auto-retry for failed operations (with exponential backoff)
- Fallback renders for when data is corrupted
- "Safe mode" that loads the app with default data if saved data 
  is corrupted beyond repair
- Data repair functions that fix common corruption patterns
- Give me the actual recovery code

Also create a HEALTH CHECK function that:
- Runs on app startup
- Validates all saved data against expected schemas
- Reports any issues found
- Repairs what it can automatically
- Warns the user about what it can't repair
- Returns a health status object

Give me all of this as actual code I can add to my app, with 
comments explaining each piece.
```

---

## SECTION 4: COMPONENT-LEVEL BULLETPROOFING
*"Every button, every hover, every interaction ‚Äî verified and hardened"*

### PROMPT 4A: "The Complete Component Audit"

```
Audit every interactive component in this application. For each one, 
verify it works correctly and identify anything missing.

[Paste your code]

For EVERY interactive element (buttons, inputs, links, dropdowns, 
modals, cards, toggles, tabs, drag targets, etc.), fill out this card:

COMPONENT: [element description]
LOCATION: [where in code]
TYPE: Button / Input / Link / Modal / Card / Toggle / Tab / Dropdown / Other

STATES IMPLEMENTED:
  ‚ñ° Default ‚Äî [description of appearance] ‚úÖ/‚ùå
  ‚ñ° Hover ‚Äî [description of hover effect] ‚úÖ/‚ùå
  ‚ñ° Active/Pressed ‚Äî [description of press effect] ‚úÖ/‚ùå
  ‚ñ° Focus ‚Äî [description of focus ring/outline] ‚úÖ/‚ùå
  ‚ñ° Disabled ‚Äî [description + is it ever disabled?] ‚úÖ/‚ùå
  ‚ñ° Loading ‚Äî [description + does it need one?] ‚úÖ/‚ùå/N/A
  ‚ñ° Error ‚Äî [description + does it need one?] ‚úÖ/‚ùå/N/A
  ‚ñ° Success ‚Äî [description + does it need one?] ‚úÖ/‚ùå/N/A
  ‚ñ° Empty ‚Äî [description + does it need one?] ‚úÖ/‚ùå/N/A
  ‚ñ° Selected/Active ‚Äî [description + does it need one?] ‚úÖ/‚ùå/N/A

BEHAVIOR:
  ‚ñ° Click handler exists? ‚úÖ/‚ùå
  ‚ñ° Click handler does what's expected? ‚úÖ/‚ùå
  ‚ñ° Keyboard accessible? (Enter/Space triggers it) ‚úÖ/‚ùå
  ‚ñ° Double-click protected? (won't fire twice) ‚úÖ/‚ùå
  ‚ñ° Provides feedback after action? (toast, visual change) ‚úÖ/‚ùå
  ‚ñ° Cursor style correct? (pointer for clickable) ‚úÖ/‚ùå

CSS VERIFICATION:
  ‚ñ° Has transition/animation for state changes? ‚úÖ/‚ùå
  ‚ñ° Transition is smooth (not instant, not sluggish)? ‚úÖ/‚ùå
  ‚ñ° Consistent with other similar components? ‚úÖ/‚ùå
  ‚ñ° Works at mobile sizes? ‚úÖ/‚ùå
  ‚ñ° Touch target large enough (min 44x44px)? ‚úÖ/‚ùå

MISSING STATES ‚Äî list the exact CSS needed to add them:
[CSS code for each missing state]

SUMMARY:
Total components audited: [N]
Fully complete: [N]
Missing 1-2 states: [N]
Missing 3+ states: [N]
Critical gaps (no click handler, no hover, broken): [N]
```

### PROMPT 4B: "The Interaction Flow Verifier"

```
For every user action possible in this application, trace the 
complete flow from click to result and verify nothing is broken 
or missing along the way.

[Paste your code]

For each action, trace:

ACTION: [what the user does ‚Äî e.g., "clicks Add Task button"]

FLOW:
  1. User [action] ‚Üí
  2. Event fires: [which event, which handler] ‚Üí
  3. Handler does: [step-by-step what the code does] ‚Üí
  4. State changes: [what data changes] ‚Üí
  5. Save triggered: [yes/no ‚Äî if no, data could be lost] ‚Üí
  6. UI updates: [what re-renders or changes visually] ‚Üí
  7. User sees: [the result ‚Äî what changes on screen]

VERIFICATION:
  ‚úÖ Event handler exists and is correctly attached
  ‚úÖ Handler logic is correct
  ‚úÖ State is properly updated
  ‚úÖ Save is triggered after state change
  ‚úÖ UI reflects the new state
  ‚úÖ User gets clear feedback the action worked
  
  OR
  
  ‚ùå [step that fails] ‚Äî [why it fails] ‚Äî [how to fix]

EDGE CASES FOR THIS ACTION:
  - What if user does this with no data?
  - What if user does this twice rapidly?
  - What if the target data was deleted by another process?
  - What if the required DOM element doesn't exist?

Test THESE specific actions at minimum:
  ‚ñ° Create a new item (in every section that allows creation)
  ‚ñ° Edit an existing item
  ‚ñ° Delete an item
  ‚ñ° Move/reorder an item (drag and drop)
  ‚ñ° Filter/search items
  ‚ñ° Navigate between pages
  ‚ñ° Open a modal
  ‚ñ° Close a modal (button, escape key, click outside)
  ‚ñ° Change a setting
  ‚ñ° Save data
  ‚ñ° Load/refresh the page
```

### PROMPT 4C: "The CSS Completeness Audit"

```
Audit every CSS rule in this application for completeness, 
consistency, and correctness. I want zero visual bugs.

[Paste your CSS]

CHECK THESE CATEGORIES:

1. TRANSITION COMPLETENESS:
   Every element with a :hover, .active, or state change MUST have 
   a transition property. Find every element that changes appearance 
   on interaction but has no transition.
   
   List: [selector] ‚Üí [property that changes] ‚Üí ‚ùå no transition
   Fix: [add transition: property duration easing]

2. HOVER STATE COMPLETENESS:
   Every clickable element (buttons, links, cards with onclick, 
   nav items) MUST have a :hover style.
   
   List: [selector] ‚Üí [clickable because of X] ‚Üí ‚ùå no :hover
   Fix: [suggested hover CSS]

3. FOCUS STATE COMPLETENESS:
   Every interactive element MUST have a visible :focus or 
   :focus-visible state for keyboard users.
   
   List: [selector] ‚Üí ‚ùå no :focus style
   Fix: [suggested focus CSS]

4. OVERFLOW HANDLING:
   Every container with dynamic content MUST handle overflow.
   
   List: [selector] ‚Üí [could overflow because X] ‚Üí 
         [has overflow handling? hidden/scroll/ellipsis]
   Missing: [add overflow: hidden / text-overflow: ellipsis / etc.]

5. Z-INDEX AUDIT:
   List every z-index in the codebase, sorted by value.
   
   [selector] ‚Üí z-index: [value] ‚Üí [purpose]
   
   CONFLICTS: Any elements on the same z-index that could overlap?
   GAPS: Any elements that should stack differently?
   RECOMMENDATION: A clean z-index scale

6. RESPONSIVE COVERAGE:
   For each major layout section, does it have responsive handling?
   
   [section] ‚Üí breakpoint coverage:
     ‚ñ° < 480px (small phone): ‚úÖ/‚ùå
     ‚ñ° 480-768px (large phone): ‚úÖ/‚ùå  
     ‚ñ° 768-1024px (tablet): ‚úÖ/‚ùå
     ‚ñ° 1024-1280px (small desktop): ‚úÖ/‚ùå
     ‚ñ° 1280px+ (large desktop): ‚úÖ/‚ùå

7. DEAD CSS:
   Find every CSS rule that doesn't match any element in the HTML.
   These are dead weight ‚Äî clutter that confuses maintenance.
   
   List: [selector] ‚Üí no matching HTML element found ‚Äî SAFE TO DELETE

8. SPECIFICITY CONFLICTS:
   Find any cases where two CSS rules target the same element 
   and could conflict, where the "winner" might not be the 
   intended rule.
   
   [rule A] vs [rule B] ‚Üí both target [element] ‚Üí 
   [which wins] ‚Üí [is that correct?]
```

### PROMPT 4D: "The Unbreakable Component Pattern"

```
I want you to rewrite this component using the UNBREAKABLE PATTERN ‚Äî 
a coding pattern that makes it virtually impossible for the component 
to crash the application, regardless of input.

[Paste a specific component/function]

THE UNBREAKABLE PATTERN has these layers:

LAYER 1 ‚Äî GUARD CLAUSE (reject bad input immediately)
function myComponent(data) {
  // Guard: bail safely if input is wrong
  if (!data || typeof data !== 'object') {
    return renderEmptyState('No data available');
  }

LAYER 2 ‚Äî SAFE EXTRACTION (get values with fallbacks for everything)
  // Extract with defaults ‚Äî NOTHING can be undefined
  const title = String(data.title || 'Untitled');
  const count = Number(data.count) || 0;
  const items = Array.isArray(data.items) ? data.items : [];
  const date = isValidDate(data.date) ? data.date : null;

LAYER 3 ‚Äî SAFE TRANSFORMATION (process data without risk)
  // Filter/map/sort with safety
  const validItems = items.filter(item => item && item.id);
  const sorted = [...validItems].sort((a, b) => 
    (a.order || 0) - (b.order || 0)
  );

LAYER 4 ‚Äî SAFE RENDER (build HTML that can't fail)
  // Build output ‚Äî every expression has a fallback
  const html = `
    <div class="component">
      <h3>${escapeHtml(title)}</h3>
      <span>${count} item${count !== 1 ? 's' : ''}</span>
      ${sorted.length > 0 
        ? sorted.map(item => renderItem(item)).join('') 
        : '<div class="empty">No items yet</div>'
      }
    </div>
  `;

LAYER 5 ‚Äî SAFE DOM UPDATE (update the page without crashing)
  const el = document.getElementById(targetId);
  if (el) el.innerHTML = html;
  // Else: element doesn't exist, but app doesn't crash

LAYER 6 ‚Äî SAFE EVENT BINDING (attach events that handle errors)
  const el = document.getElementById(targetId);
  if (el) {
    el.addEventListener('click', (e) => {
      try {
        handleClick(e);
      } catch (err) {
        console.warn('Click handler failed:', err);
        // App keeps running
      }
    });
  }
}

Now apply ALL SIX LAYERS to the code I gave you. 
Show me the complete rewrite with every layer labeled in comments.
Then list what was UNSAFE in the original that is now SAFE.
```

---

## SECTION 5: FUTURE-PROOFING
*"Make sure what works today still works after 50 more features"*

### PROMPT 5A: "The Breaking Point Predictor"

```
Analyze this codebase and predict what will break as the app grows. 
I want to fix structural weaknesses BEFORE they become bugs.

[Paste your code or describe your app architecture]

PREDICT THESE BREAKING POINTS:

SCALE BREAKING POINTS:
- At what number of [items] will the list/view become unusable?
  (e.g., "100 tasks will make the kanban scroll too long")
- At what data size will localStorage run out?
- At what complexity will the render functions become too slow?
- At what file size will the codebase become unmanageable?
- For each: what's the fix BEFORE we hit that limit?

FEATURE CONFLICT PREDICTIONS:
- Which planned features will conflict with existing architecture?
- Which existing patterns will need to change for upcoming needs?
- Which global variables will collide with future additions?
- Which CSS class names will conflict with new components?
- For each: what to change NOW to prevent the conflict

MAINTENANCE BREAKING POINTS:
- Which parts of the code will be hardest to modify later?
- Which functions do too many things (violate single responsibility)?
- Which areas have the most "tribal knowledge" (only make sense if 
  you know the history)?
- Which patterns are used inconsistently (some pages do X, others do Y)?
- For each: what refactoring prevents future headaches

DEPENDENCY RISK:
- Which external libraries/CDNs could break if they go down?
- Which browser APIs used could become deprecated?
- Which patterns assume a specific environment that could change?
- For each: what's the fallback plan

OUTPUT:
Create a RISK REGISTRY:
| Risk | Likelihood | Impact | When It Hits | Prevention | Fix Cost Now | Fix Cost Later |
Format from highest risk to lowest.
```

### PROMPT 5B: "The Contract Enforcer"

```
Define and implement CONTRACTS for every public function and data 
interface in this application. A contract is a set of rules that 
says "this function promises to ALWAYS behave this way, and callers 
promise to ALWAYS provide this input."

[Paste your code]

For each function that is called by other functions, define:

FUNCTION: [name]

INPUT CONTRACT (what callers MUST provide):
  - Parameter 1: [name] | [type] | [required?] | [valid values/range]
  - Parameter 2: [name] | [type] | [required?] | [valid values/range]

OUTPUT CONTRACT (what this function ALWAYS returns):
  - Return type: [type]
  - Return structure: [shape of the returned data]
  - Never returns: [null? undefined? Error? NaN?]
  - Side effects: [does it modify state? DOM? localStorage?]

ERROR CONTRACT (what happens when things go wrong):
  - Invalid input: [returns default / throws / ignores]
  - Missing dependency: [returns default / throws / ignores]
  - Runtime error: [caught and handled / propagates up]

CURRENT VIOLATIONS:
  - [Caller X passes wrong type at line Y]
  - [Function returns undefined when Z is empty, but caller assumes string]
  - [Function has undocumented side effect: modifies global state]

ENFORCEMENT CODE:
For each function, generate a guard block that ENFORCES the 
input contract at runtime:

function example(task, status) {
  // CONTRACT ENFORCEMENT
  if (!task || typeof task !== 'object') return null;
  if (!['new','progress','done'].includes(status)) status = 'new';
  // ... rest of function
}
```

### PROMPT 5C: "The Regression Shield"

```
Create a manual testing checklist that I can run after EVERY code 
change to verify nothing broke. This is my regression shield ‚Äî 
the thing that catches bugs before they go live.

[Paste your code or describe all features]

Generate a checklist organized by app section:

## PRE-CHECK (before testing)
‚ñ° Open browser dev tools (F12)
‚ñ° Check Console tab ‚Äî any red errors? 
‚ñ° Check Network tab ‚Äî any failed requests?
‚ñ° Clear console, then reload page ‚Äî errors on startup?

## CORE SYSTEMS
‚ñ° Page loads completely (no white screen, no missing sections)
‚ñ° Sidebar navigation visible with all menu items
‚ñ° Click each nav item ‚Äî correct page loads
‚ñ° Clock in header updates every second
‚ñ° Status indicators show correct state
‚ñ° No layout shifts or jumping elements during load

## [FOR EACH PAGE/FEATURE ‚Äî generate specific checks]:

### TASKBOARD
‚ñ° All kanban columns render with correct headers
‚ñ° Task cards display in correct columns
‚ñ° Can drag a card from one column to another
‚ñ° Card drops in new column and persists after refresh
‚ñ° Can click a card to open detail modal
‚ñ° Detail modal shows all fields
‚ñ° Can edit task title ‚Äî saves correctly
‚ñ° Can change task priority ‚Äî visual indicator updates
‚ñ° Can close modal (X button, Escape key, click outside)
‚ñ° Badge count in sidebar matches task count

### CRM
‚ñ° Pipeline kanban view loads with all stages
‚ñ° Client cards show in correct stages
‚ñ° Can click a client to open detail modal
‚ñ° Detail modal tabs all work (Client, Activity, Tasks, etc.)
‚ñ° Can edit client fields ‚Äî saves on blur
‚ñ° Can add tags ‚Äî tag appears immediately
‚ñ° Can add tasks to a client ‚Äî task appears in list
‚ñ° Pipeline selector changes the view
‚ñ° Overdue indicators show correctly

### [Continue for EVERY section...]

## POST-CHECK
‚ñ° Refresh the page ‚Äî everything still works
‚ñ° Close browser, reopen ‚Äî data persisted
‚ñ° Check console ‚Äî any new errors that weren't there before?

## IF ANYTHING FAILS:
1. Do NOT make more changes
2. Note which check failed
3. Revert to backup
4. Fix the specific issue
5. Re-run the FULL checklist

This checklist should take 5-10 minutes to run through.
Every minute spent here saves an hour of debugging later.
```

---

## SECTION 6: THE MASTER VALIDATION PROMPT
*"Run this to do EVERYTHING at once"*

### PROMPT 6: "The Full Structural Integrity Scan"

```
Perform a complete structural integrity scan on this application.
This is the most thorough review possible ‚Äî check everything.

[Paste your code]

RUN THESE SCANS IN ORDER:

SCAN 1 ‚Äî SYNTAX & RUNTIME SAFETY
- Any syntax errors that would prevent loading?
- Any runtime errors that would crash on interaction?
- Any undefined variables referenced?
- Any functions called that don't exist?
‚òê PASS / ‚òê FAIL ‚Äî [issues found]

SCAN 2 ‚Äî LOGIC CORRECTNESS
- Do all functions do what their names imply?
- Do all conditionals handle all cases?
- Do all loops terminate correctly?
- Do all calculations produce correct results?
‚òê PASS / ‚òê FAIL ‚Äî [issues found]

SCAN 3 ‚Äî DATA INTEGRITY
- Is all data saved when it should be?
- Is loaded data validated before use?
- Can data become corrupted? How?
- Are there orphaned references?
‚òê PASS / ‚òê FAIL ‚Äî [issues found]

SCAN 4 ‚Äî UI COMPLETENESS
- Does every interactive element have all states?
- Does every action provide user feedback?
- Are empty/loading/error states handled?
- Is the UI consistent across all pages?
‚òê PASS / ‚òê FAIL ‚Äî [issues found]

SCAN 5 ‚Äî DEFENSIVE CODING
- Are all external inputs sanitized?
- Are all optional values given defaults?
- Are all DOM queries null-checked?
- Are all risky operations try/caught?
‚òê PASS / ‚òê FAIL ‚Äî [issues found]

SCAN 6 ‚Äî PERFORMANCE
- Any operations that scale poorly?
- Any unnecessary re-renders?
- Any memory leaks (listeners, timers, closures)?
- Any blocking operations on the main thread?
‚òê PASS / ‚òê FAIL ‚Äî [issues found]

SCAN 7 ‚Äî MAINTAINABILITY
- Any duplicated code that should be shared?
- Any functions doing too many things?
- Any unclear naming?
- Any missing comments on complex logic?
‚òê PASS / ‚òê FAIL ‚Äî [issues found]

FINAL REPORT:
Scans passed: [X/7]
Critical issues: [count + list]
Important issues: [count + list]  
Minor issues: [count + list]
Overall integrity: üü¢ SOLID / üü° NEEDS WORK / üî¥ AT RISK

RECOMMENDED ACTIONS (in priority order):
1. [Most critical fix] ‚Äî [why] ‚Äî [effort]
2. [Second priority] ‚Äî [why] ‚Äî [effort]
3. [Third priority] ‚Äî [why] ‚Äî [effort]
... (continue for all critical + important issues)
```

---

## HOW TO USE THIS WITH YOUR CCRM

You don't run all of these on 7,333 lines at once. That's too much 
for any AI to handle well. Instead:

### Weekly Rhythm:

**Monday**: Run Prompt 3A (Foundation Health Check) on core systems only
  - Paste lines 1155-1320 (state, constants, navigation)
  - Verify the base is solid before the week's work

**Before each work session**: Run Prompt 4B (Interaction Flow Verifier) 
on just the section you're about to modify
  - Working on CRM? Paste lines 6400-7150
  - Working on TaskBoard? Paste lines 1320-1450

**After each work session**: Run Prompt 5C (Regression Shield)
  - Click through the manual checklist
  - 5 minutes. Non-negotiable.

**Friday**: Run Prompt 2A (Architecture Efficiency Review) on whatever 
you built that week
  - Did you add code efficiently, or create debt?

**Monthly**: Run Prompt 6 (Full Structural Integrity Scan) on the 
whole file, in sections:
  - First pass: CSS (lines 1-930)
  - Second pass: HTML (lines 930-1155)
  - Third pass: Core JS (lines 1155-1450)
  - Fourth pass: Feature JS (lines 1450-6400)
  - Fifth pass: CRM System (lines 6400-7150)
  - Sixth pass: Sync (lines 7150-7333)

### The Rule:
**Audit BEFORE you build. Verify AFTER you build. Never skip either.**
